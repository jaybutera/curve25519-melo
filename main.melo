#require "signed_int.melo"

struct U512 {
    low: Nat,
    high: Nat,
}

struct Point {
    x: Nat,
    y: Nat,
}

def to_u512(x: Nat) = U512 { low: x, high: 0 }

def add_u512(x: U512, y: U512): U512 =
    let low = x.low + y.low in
    # If there was an overflow
    let high =
        if low < x.low then
            x.high + y.high + 1
        else
            x.high + y.high in
    U512 {
        low: low,
        high: high,
    }

def add_nat_to_u512(x: Nat, y: Nat): U512 =
    let low = x + y in
    # If there was an overflow
    if low < x then
        U512 { low: low, high: 1 }
    else
        U512 { low: low, high: 0 }

def addq(x: Nat, y: Nat): Nat =
    modq(add_nat_to_u512(x, y))

# Uses 512 as intermediate repr and modq to produce a Nat
#def mulq(x: Nat, y: Nat): Nat = modq(mul_nat_to_u512(x, y))

# Convenient multiply fn
#def mul_nat_to_u512(x: Nat, y: Nat): U512 =
def mulq(x: Nat, y: Nat): Nat =
    #let res = U512 { low: 0, high: 0 } in
    let res = 0 :: Nat in
    loop 256 do
        #set! res = if y % 2 == 1 then add_u512(res, to_u512(x)) else res;
        set! res = if y % 2 == 1 then addq(res, x) else res;
        set! x = x << 1;
        set! y = y >> 1;
    done with res

def expq(base: Nat, exp: Nat): Nat =
    let res = 1 :: Nat in
    loop 256 do
        set! res = if exp & 1 then
                #mulq(res, mulq(base, base))
                mulq(res, base)
            else
                res;
                #mulq(res, base);
        set! base = mulq(base, base);
        set! exp = exp >> 1;
    done with res

def modq(x: U512): Nat =
    #let q = 2**255-19 in
    let q = 7 in
    let k = 2**256 % q in
    (k * (x.high % q) % q) + (x.low % q)

def inverse(x: Nat): Nat =
    let c = x in
    # Loop 254 - 5, since bits at index 4 and 2 are 0, manually compute the rest
    let c1 = loop 249 do
        set! c = mulq(mulq(c, c), x);
    done with c in
    let s5 = mulq(c1, c1) in
    let s4 = mulq(mulq(s5, s5), x) in
    let s3 = mulq(s4, s4) in
    let s2 = mulq(mulq(s3, s3), x) in
    let s1 = mulq(mulq(s2, s2), x) in
    s1

def scalar_mul(p: Nat, i: Nat): Nat =
    # 0x7f11111111111111111111111111111111111111111111111111111111f8
    #let clamp_const1 = 876521786042401601004213994509182232461290839465639092505640576422510840 in
    let clamp_const1 = 876981902465520971923376311566667367491454246730450451609318078037430776 in
    # 0x40000000000000000000000000000000000000000000000000000000000000
    #let clamp_const2 = 114845059210594981422914337548289703528786453296915232277904403084020285439 in
    let clamp_const2 = 113078212145816597093331040047546785012958969400039613319782796882727665664 in
    # i with constraints for security
    let clamped = i & clamp_const1 | clamp_const2 in
    # Shifts right each iteration to get the lsb
    let moving_clamped = clamped in
    let bit = 0 :: Nat in
    let x = p in
    let a = 1 :: Nat in
    let b = x in
    let c = 0 :: Nat in
    let d = 1 :: Nat in
    let e = 0 :: Nat in
    let f = 0 :: Nat in

    loop 255 do
        # Get lsb
        set! bit = moving_clamped & 1;
        # Shift for new lsb
        set! moving_clamped = moving_clamped >> 1;
        # Swap a&b if bit
        set! a = if bit then b else a;
        set! b = if bit then a else b;
        # Swap c&d if bit
        set! c = if bit then d else c;
        set! d = if bit then c else d;
        # Maths
        set! e = addq(a, c);
        set! a = a - c;
        set! c = addq(b, d);
        set! b = b - d;
        set! d = mulq(e, e);
        set! f = mulq(a, a);
        set! a = mulq(c, a);
        set! c = mulq(b, e);
        set! e = addq(a, c);
        set! a = a - c;
        set! b = mulq(a, a);
        set! c = d - f;
        set! a = mulq(c, 121665);
        set! a = addq(a, d);
        set! c = mulq(c, a);
        set! a = mulq(d, f);
        set! d = mulq(b, x);
        set! b = mulq(e, e);
        # Swap a&b if bit
        set! a = if bit then b else a;
        set! b = if bit then a else b;
        # Swap c&d if bit
        set! c = if bit then d else c;
        set! d = if bit then c else d;
    done with mulq(a, inverse(c))
    #done with a

def generate<$x>(n: {$x}) =
    #let g = Point { x: 9, y: 2687234 } in
    let g = Point { x: 14847277145635483483963372537557091634710985132825781088887140890597596352251, y: 48981431527428949880507557032295310859754924433568441600873610210018059225738 } in
    #let g = Point { x: 9, y: 14781619447589544791020593568409986887264606134616475288964881837755586237401 } in
    let res = g in
    loop $x do
        set! res = add_point(res, g);
    done with res


def add_point(a: Point, b: Point) =
    let const_a = 486662 in
    let k_a = const_a * 2 in
    # TODO handle if b = -a
    if a.x == b.x then
        Point {
            #x: ((3*a.x*a.x + 2*const_a*a.x + 1) / (2*a.y))**2 - const_a - 2*a.x,
            x: expq(addq(mulq(3,mulq(a.x, a.x)), addq(mulq(k_a, a.x), 1)) / mulq(2, a.y), 2) - const_a - mulq(2, a.x),
            #y: (((2*a.x + b.x + const_a) * (3*a.x*a.x + 2*const_a*a.x+1)) / (2*a.y)) - ((3*a.x*a.x + 2*const_a*a.x + 1) / (2*a.y))**3 - a.y
            y: mulq(addq(addq(mulq(2,a.x), b.x), const_a), addq(mulq(3,mulq(a.x,a.x)), addq(mulq(k_a,a.x), 1))) / mulq(2,a.y)
                - expq(addq(mulq(3,mulq(a.x,a.x)), addq(mulq(k_a,a.x), 1)) / mulq(2,a.y), 3) - a.y,
        }
    else
        Point {
            #x: ((b.y - a.y) / (b.x - a.x))**2 - const_a - a.x - b.x,
            x: expq((b.y - a.y) / (b.x - a.x), 2) - const_a - a.x - b.x,
            #y: (((2*a.x + b.x + const_a) * (b.y - a.y)) / (b.x - a.x)) - ((b.y - a.y) / (b.x - a.x))**3 - a.y
            y: mulq(addq(mulq(2, a.x), addq(b.x, const_a)), b.y - a.y) / (b.x - a.x) - expq((b.y - a.y) / (b.x - a.x), 3) - a.y
        }

# 2G
#( 14847277145635483483963372537557091634710985132825781088887140890597596352251 , 48981431527428949880507557032295310859754924433568441600873610210018059225738 )


---
let a = Point { x: 1, y: 1 } in
let b = Point { x: 2, y: 1 } in
#generate(2)
#let g1 = Point { x: 14847277145635483483963372537557091634710985132825781088887140890597596352251, y: 48981431527428949880507557032295310859754924433568441600873610210018059225738 } in
#let ng1 = Point { x: 14847277145635483483963372537557091634710985132825781088887140890597596352251, y: negate(48981431527428949880507557032295310859754924433568441600873610210018059225738) } in
#add_point(g1,ng1)
#expq(2, 4)
#scalar_mul(9, 2)
#inverse(inverse(9))
let x2253 = 14474011154664524427946373126085988481658748083205070504932198000989141204992 in
let x22561 = 115792089237316195423570985008687907853269984665640564039457584007913129639935 in
#mul_nat_to_u512(x22561,x22561)
mulq(41,x2253)
#add_u512(to_u512(x22561),to_u512(x22561))
#scalar_mul(9, inverse(9))
